import { Plugin } from '../../core/plugin';
import { VeloceTS } from '../../core/application';
import { PrismaConfig, PrismaClientLike, PrismaModelMetadata } from './types';
import { PrismaZodSchemaGenerator } from './schema-generator';
import { PrismaRepository as PrismaRepositoryClass } from './repository';
import { PrismaTransactionManager } from './transaction-manager';
import { setGlobalTransactionManager } from '../transaction-manager';
import { Repository } from '../decorators';
import fs from 'fs';
import path from 'path';

/**
 * Prisma integration plugin for FastAPI-TS
 */
export class PrismaPlugin implements Plugin {
  name = 'prisma';
  version = '1.0.0';
  
  private client: PrismaClientLike;
  private config: PrismaConfig;
  private schemaGenerator: PrismaZodSchemaGenerator;
  private transactionManager: PrismaTransactionManager;
  private models: Map<string, PrismaModelMetadata> = new Map();
  
  constructor(client: PrismaClientLike, config?: PrismaConfig) {
    this.client = client;
    this.config = {
      generateZodSchemas: true,
      schemaPath: './prisma/schema.prisma',
      outputPath: './src/generated/zod-schemas.ts',
      ...config
    };
    this.schemaGenerator = new PrismaZodSchemaGenerator();
    this.transactionManager = new PrismaTransactionManager(client);
  }
  
  async install(app: VeloceTS): Promise<void> {
    // Connect to database
    await this.client.$connect();
    
    // Set global transaction manager
    setGlobalTransactionManager(this.transactionManager);
    
    // Parse Prisma schema if available
    if (this.config.generateZodSchemas && this.config.schemaPath) {
      await this.parseAndGenerateSchemas();
    }
    
    // Register repository factory in DI container
    this.registerRepositoryFactory(app);
    
    // Add cleanup on app shutdown
    this.registerShutdownHook(app);
    
    console.log('‚úÖ Prisma plugin installed successfully');
  }
  
  /**
   * Parse Prisma schema and generate Zod schemas
   */
  private async parseAndGenerateSchemas(): Promise<void> {
    try {
      if (!fs.existsSync(this.config.schemaPath!)) {
        console.warn(`‚ö†Ô∏è  Prisma schema not found at ${this.config.schemaPath}`);
        return;
      }
      
      const schemaContent = fs.readFileSync(this.config.schemaPath!, 'utf-8');
      const models = PrismaZodSchemaGenerator.parsePrismaSchema(schemaContent);
      
      // Store models and generate schemas
      for (const model of models) {
        this.models.set(model.name, model);
        
        // Generate Zod schemas
        const schemas = this.schemaGenerator.generateAllSchemas(model);
        model.zodSchema = schemas.base;
      }
      
      // Generate TypeScript file with Zod schemas
      if (this.config.outputPath) {
        await this.generateZodSchemaFile();
      }
      
      console.log(`üìù Generated Zod schemas for ${models.length} models`);
    } catch (error) {
      console.error('‚ùå Failed to parse Prisma schema:', error);
    }
  }
  
  /**
   * Generate TypeScript file with Zod schemas
   */
  private async generateZodSchemaFile(): Promise<void> {
    const outputDir = path.dirname(this.config.outputPath!);
    
    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    let content = `// Auto-generated Zod schemas from Prisma schema\n`;
    content += `// Do not edit this file manually\n\n`;
    content += `import { z } from 'zod';\n\n`;
    
    // Generate schemas for each model
    for (const [modelName, model] of this.models) {
      const schemas = this.schemaGenerator.generateAllSchemas(model);
      
      content += `// ${modelName} schemas\n`;
      content += `export const ${modelName}Schema = ${this.zodSchemaToString(schemas.base)};\n`;
      content += `export const ${modelName}CreateSchema = ${this.zodSchemaToString(schemas.create)};\n`;
      content += `export const ${modelName}UpdateSchema = ${this.zodSchemaToString(schemas.update)};\n\n`;
      
      // Generate TypeScript types
      content += `export type ${modelName} = z.infer<typeof ${modelName}Schema>;\n`;
      content += `export type ${modelName}Create = z.infer<typeof ${modelName}CreateSchema>;\n`;
      content += `export type ${modelName}Update = z.infer<typeof ${modelName}UpdateSchema>;\n\n`;
    }
    
    fs.writeFileSync(this.config.outputPath!, content);
  }
  
  /**
   * Convert Zod schema to string representation (simplified)
   */
  private zodSchemaToString(schema: any): string {
    // This is a simplified implementation
    // In a real implementation, you'd want a proper schema serializer
    return 'z.object({})'; // Placeholder
  }
  
  /**
   * Register repository factory in DI container
   */
  private registerRepositoryFactory(app: VeloceTS): void {
    const container = app.getContainer();
    
    // Create token classes for DI registration
    class PrismaRepositoryFactoryToken {}
    class TransactionManagerToken {}
    
    // Register a factory for creating Prisma repositories
    container.register(PrismaRepositoryFactoryToken, {
      scope: 'singleton',
      factory: () => ({
        create: <T>(modelName: string, zodSchema?: any) => {
          const delegate = (this.client as any)[modelName.toLowerCase()];
          if (!delegate) {
            throw new Error(`Model ${modelName} not found in Prisma client`);
          }
          
          return new PrismaRepositoryClass<T>({
            client: this.client,
            delegate,
            model: modelName,
            zodSchema
          });
        }
      })
    });
    
    // Register transaction manager
    container.register(TransactionManagerToken, {
      scope: 'singleton',
      factory: () => this.transactionManager
    });
  }
  
  /**
   * Register shutdown hook to disconnect from database
   */
  private registerShutdownHook(app: VeloceTS): void {
    // Add shutdown handler
    process.on('SIGINT', async () => {
      console.log('üîå Disconnecting from database...');
      await this.client.$disconnect();
      process.exit(0);
    });
    
    process.on('SIGTERM', async () => {
      console.log('üîå Disconnecting from database...');
      await this.client.$disconnect();
      process.exit(0);
    });
  }
  
  /**
   * Get model metadata
   */
  getModel(name: string): PrismaModelMetadata | undefined {
    return this.models.get(name);
  }
  
  /**
   * Get all models
   */
  getModels(): Map<string, PrismaModelMetadata> {
    return this.models;
  }
  
  /**
   * Create a repository for a specific model
   */
  createRepository<T>(modelName: string, zodSchema?: any): PrismaRepositoryClass<T> {
    const delegate = (this.client as any)[modelName.toLowerCase()];
    if (!delegate) {
      throw new Error(`Model ${modelName} not found in Prisma client`);
    }
    
    return new PrismaRepositoryClass<T>({
      client: this.client,
      delegate,
      model: modelName,
      zodSchema
    });
  }
  
  /**
   * Get the Prisma client
   */
  getClient(): PrismaClientLike {
    return this.client;
  }
  
  /**
   * Get the transaction manager
   */
  getTransactionManager(): PrismaTransactionManager {
    return this.transactionManager;
  }
}

/**
 * Helper function to create Prisma plugin
 */
export function createPrismaPlugin(client: PrismaClientLike, config?: PrismaConfig): PrismaPlugin {
  return new PrismaPlugin(client, config);
}

/**
 * Decorator to automatically inject Prisma repository
 */
export function PrismaRepository(modelName: string, zodSchema?: any): PropertyDecorator {
  return (target: any, propertyKey: string | symbol) => {
    // This will be resolved by the DI container
    const metadata = {
      type: 'prisma-repository',
      modelName,
      zodSchema
    };
    
    Reflect.defineMetadata('inject', metadata, target, propertyKey);
  };
}